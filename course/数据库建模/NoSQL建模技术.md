# NoSQL建模技术

- 键值存储数据库:Oracle Coherence,Redis,Kyoto Cabinet
- Big Table存储数据库:Apache HBase,Apache Cassandra
- 文档数据库:MongoDB,CouchDB
- 全文搜索引擎:Apache Lucene,Apache Solr,ES
- 图形数据库:Neo4j,FlockDB

+ [概念技术](#概念技术) 
+ [一般建模技术](#一般建模技术)
  
## 概念技术

- 去规范化(Denormalization)

  - 一般来说，去规范化用于以下的折衷：
  
    - 查询的数据量或每次查询IO**与总数据量的折衷。去规范化可以将一个查询所需的所有数据组合起来存放到同一个地方。这通常意味着对相同数据的不同的查询会访问不同的数据组合。因此，数据需要被复制多份，也就意味着增加了总数据量。
    - 处理复杂性与总数据量的折衷。建模时的规范化和相应查询的连接（join）明显增加了查询处理器的复杂度，在分布式系统中尤为明显。去规范化允许将数据按照查询友好的方式存储，从而简化查询的处理

  - 适用性:键值存储数据库,文档数据库,Big Table存储数据库
  
- 聚合(Aggregates)

  - 所有主流NoSQL都提供了这样或那样的松散schema（soft schema）支持
    - 键值存储和图形数据库通常不对值进行约束，所以值可能是任意格式。另外，也可以通过使用组合键将一个业务实体表示为多条记录。例如，可以将一个用户帐户建模为UserID_name，UserID_email，UserID_messages等组合键表示的一个实体集合。如果用户没有电子邮件或消息，然后相应的实体不会被记录。
    - BigTable模式也支持松散schema，因为一个列簇是可变的列集合，一个单元格又能存储不定数目的数据版本
    - 文档数据库天生就没schema，虽然某些文档数据库允许在数据输入时使用用户定义的schema进行验证
    
  - 松散schema允许使用复杂的内部结构（嵌套实体）构造实体的类，也允许改变特定实体的结构。这个更能带来了两个重要的便利
    - 通过嵌套的实体，最小化了一对多的关系，也因此减少了连接（join）
    - 异构业务实体的模型可以使用一个文档集合或者一个数据表。松散schema掩藏了这种建模和业务实体之间“技术”上的差异
    
  ![聚合](./resource/聚合.png)
  
  - 内嵌的去规范化会在性能和一致性上对更新操作造成很大的影响，所以要特别注意更新过程
  
  - 适用性:键值存储数据库,文档数据库,Big Table存储数据库
  
- 应用端连接(Application Side Joins)

  - 多对多关系往往是通过链接（link）建模的，这需要join
  
  - 聚合操作往往不适合内部实体会被频繁修改的场景。通常更好的办法是将发生的事情作为一条新的记录保留，并在查询的时候将所有记录做join，而不是去更改值。例如，对于一个信息系统而言，可以用嵌套包含了Message实体的User实体来建模。但是，如果会经常地添加消息，更好的办法可能是把Message提取出来作为独立实体，并在查询时再将其与User进行连接
  
  ![应用端连接](./resource/应用端连接.png)
  
  - 适用性:键值存储数据库,文档数据库,Big Table存储数据库,图形数据库
  
## 一般建模技术

- 原子聚合(Atomic Aggregates)

  ![原子聚合](./resource/原子聚合.png)

  - 适用性:键值存储,文档数据库,BigTable风格的数据库
- 可枚举主键(Enumerable Keys)

  - 某些NoSQL存储提供原子计数器，能生成一个顺序化的ID。在这种情况下，可以使用userID_messageID作为一个复合键来存储消息。如果最新的消息ID是已知的，那就可以遍历以前的消息。另外，对于任何一个给定的消息ID，也可以向前或向后进行遍历
  - 也可以将消息分桶（bucket），例如，每天的数据放到一个桶里。这样就允许从任何指定日期或当前日期开始，向前或向后遍历一个邮箱
  
  - 适用性:键值存储
- 降维(Dimensionality Reduction)
  - 适用性:键值存储,文档数据库,BigTable风格的数据库
- 索引表(Index Table)

  ![索引表](./resource/索引表.png)

  - 适用性:BigTable风格的数据库
- 组合主键索引(Composite Key Index)

  ![组合主键索引](./resource/组合主键索引.png)
  
  - 适用性:BigTable风格的数据库
- 组合主键的聚合

  - 复合主键不仅可用于作索引，还可以为不同类型分组。让我们来看一个例子。有一个巨大的日志数组，记录了互联网用户和他们访问不同的网站（点击流）的信息。我们的目标是对于每个唯一用户计算出每个站点的点击数量。这类似于下面的SQL查询：
  
  ![组合主键聚合查询](./resource/组合主键聚合查询.png)
  
  ![组合主键的聚合](./resource/组合主键的聚合.png)
  
  - 适用性:有序键值存储,BigTable风格的数据库
- 倒排搜索-直接聚合

  ![倒排搜索](./resource/倒排搜索.png)

  - 适用性:键值存储,BigTable风格的数据库,文档数据库
- 树聚合(Tree Aggregation)

  - 可以将一条单独的记录或者文件的模型建成树，甚至是任意的图（通过去规范化）
    - 在树会被一次性访问的场景中（例如，博客的整个评论树会被读取，并显示在一篇文章的页面中），这个技术很高效。
    - 搜索和访问任意条目可能有问题
    - 在大多数NoSQL的实现中，更新操作的效率低下（同相互独立的节点相比）
    
    ![树聚合](./resource/树聚合.png)
    
  - 适用性:键值存储,文档数据库
- 邻接列表(Adjacency Lists)
  - 适用性:键值存储,文档数据库
- 物化路径

  - 物化路径是一种有助于避免在树型结构上做递归遍历的技术。也可以认为这是一种去规范化的技术。其设计思想是用一个节点所有的父节点或者子女节点来标识该节点，这样就有可以不用遍历而得到一个节点的所有祖先节点或者衍生节点
  
  ![物化路径](./resource/物化路径.png)
  
  - 适用性:键值存储,文档数据库,搜索引擎
- 嵌套集合(Nested Sets)

  - 在对类似树型结构进行建模时，嵌套集合是个标准的做法。它在关系数据库中广泛被使用，然而它也完全适用于键值存储和文档数据库。其设计思想是在用数组来存储树的叶子节点（译者：每个叶子节点对应数组中的一个位置下标），并将每个非叶结点映射为一个叶子节点的范围，这个范围就是开始叶子节点和结束叶子节点在数组中的位置下标。如下图所示
  
  ![嵌套集合](./resource/嵌套集合.png)

  - 适用性:键值存储,文档数据库
- 扁平化嵌套文件：字段名称编号
  - 适用性:搜索引擎
- 扁平化嵌套文件：近似查询

  ![扁平化嵌套文件](./resource/扁平化嵌套文件.png)

  - 适用性:搜索引擎
- 批量图处理
  - 适用性:键值存储,文档数据库,BigTable风格的数据库